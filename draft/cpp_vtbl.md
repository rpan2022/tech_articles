# 解释一下虚函数工作原理 

我们来深入但清晰地解释 C++ 虚函数（virtual function）的工作原理。这是理解运行时多态（动态绑定）的核心机制。

## 一、目标：为什么需要虚函数？
没有 virtual 时，函数调用在编译期就确定了（静态绑定）

但我们希望：即使通过基类指针，也能调用派生类的实际实现 → 这就需要 运行时动态分发，由 virtual 实现。

## 二、核心机制：虚函数表（vtable） + 虚表指针（vptr）

C++ 编译器通过以下两个结构实现动态绑定：

1. 虚函数表（Virtual Table, vtable）
每个包含虚函数的类（或其基类有虚函数）都会在编译时生成一个 vtable。
vtable 是一个函数指针数组，按声明顺序存储该类所有虚函数的地址。
如果派生类重写了某个虚函数，vtable 中对应位置就填入派生类的版本。
2. 虚表指针（vptr）
每个对象（只要其类型有虚函数）在内存布局开头（通常）隐式包含一个指针：vptr。
vptr 指向该对象实际类型的 vtable。
✅ 关键：vptr 在构造函数中初始化，指向当前正在构造的类的 vtable。

内存结构（概念图）：

```txt
         +-----------------+
Base     | vptr ───────────┼──→ Base's vtable
         +-----------------+    +--------------+
         | ... (data)      |    | &Base::~Base |
         +-----------------+    | &Base::f     |
                                | &Base::g     |
                                +--------------+

         +-----------------+
Derived  | vptr ───────────┼──→ Derived's vtable
         +-----------------+    +-----------------+
         | ... (Base data) |    | &Derived::~Base | ← 虚析构也会被重写
         | ... (own data)  |    | &Derived::f     |
         +-----------------+    | &Base::g        | ← 未重写，仍用 Base 版本
                                +-----------------+
```

步骤：

# 1. 通过对象 p 找到其 vptr；
2. 通过 vptr 找到 vtable；
3. 根据函数在虚表中的固定偏移（由编译器决定）取出函数地址；
4. 调用该地址的函数。

✅ 因此，调用的是 p 实际指向的对象类型（Derived）的实现。


